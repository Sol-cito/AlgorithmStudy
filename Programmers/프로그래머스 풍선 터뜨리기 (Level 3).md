## 프로그래머스 풍선 터뜨리기 (Level 3)

###### 문제 설명

일렬로 나열된 n개의 풍선이 있습니다. 모든 풍선에는 서로 다른 숫자가 써져 있습니다. 당신은 다음 과정을 반복하면서 풍선들을 단 1개만 남을 때까지 계속 터트리려고 합니다.

1. 임의의 **인접한** 두 풍선을 고른 뒤, 두 풍선 중 하나를 터트립니다.
2. 터진 풍선으로 인해 풍선들 사이에 빈 공간이 생겼다면, 빈 공간이 없도록 풍선들을 중앙으로 밀착시킵니다.

여기서 조건이 있습니다. 인접한 두 풍선 중에서 **번호가 더 작은 풍선**을 터트리는 행위는 최대 1번만 할 수 있습니다. 즉, 어떤 시점에서 인접한 두 풍선 중 번호가 더 작은 풍선을 터트렸다면, 그 이후에는 인접한 두 풍선을 고른 뒤 번호가 더 큰 풍선만을 터트릴 수 있습니다.

당신은 어떤 풍선이 최후까지 남을 수 있는지 알아보고 싶습니다. 위에 서술된 조건대로 풍선을 터트리다 보면, 어떤 풍선은 최후까지 남을 수도 있지만, 어떤 풍선은 무슨 수를 쓰더라도 마지막까지 남기는 것이 **불가능**할 수도 있습니다.

일렬로 나열된 풍선들의 번호가 담긴 배열 a가 주어집니다. 위에 서술된 규칙대로 풍선들을 1개만 남을 때까지 터트렸을 때 최후까지 남기는 것이 가능한 풍선들의 개수를 return 하도록 solution 함수를 완성해주세요.

------

##### 제한 사항

- a의 길이는 1 이상 1,000,000 이하입니다.
  - `a[i]`는 i+1 번째 풍선에 써진 숫자를 의미합니다.
  - a의 모든 수는 -1,000,000,000 이상 1,000,000,000 이하인 정수입니다.
  - a의 모든 수는 서로 다릅니다.

------

##### 입출력 예

| a                                       | result |
| --------------------------------------- | ------ |
| `[9,-1,-5]`                             | 3      |
| `[-16,27,65,-2,58,-92,-71,-68,-61,-33]` | 6      |

------

##### 입출력 예 설명

입출력 예 #1

- 첫 번째 풍선(9가 써진 풍선)을 최후까지 남기는 방법은 다음과 같습니다.
  1. `[9, -1, -5]` 에서 -1, -5가 써진 풍선을 고른 뒤, -1이 써진 풍선(번호가 더 큰 것)을 터트립니다.
  2. `[9, -5]` 에서 9, -5가 써진 풍선을 고른 뒤, -5가 써진 풍선(번호가 더 작은 것)을 터트립니다.
- 두 번째 풍선(-1이 써진 풍선)을 최후까지 남기는 방법은 다음과 같습니다.
  1. `[9, -1, -5]` 에서 9, -1이 써진 풍선을 고른 뒤, 9가 써진 풍선(번호가 더 큰 것)을 터트립니다.
  2. `[-1, -5]` 에서 -1, -5가 써진 풍선을 고른 뒤, -5가 써진 풍선(번호가 더 작은 것)을 터트립니다.
- 세 번째 풍선(-5가 써진 풍선)을 최후까지 남기는 방법은 다음과 같습니다.
  1. `[9, -1, -5]` 에서 9, -1이 써진 풍선을 고른 뒤, 9가 써진 풍선(번호가 더 큰 것)을 터트립니다.
  2. `[-1, -5]` 에서 -1, -5가 써진 풍선을 고른 뒤, -1이 써진 풍선(번호가 더 큰 것)을 터트립니다.
- 3개의 풍선이 최후까지 남을 수 있으므로, 3을 return 해야 합니다.

입출력 예 #2

- 최후까지 남을 수 있는 풍선은 -16, -92, -71, -68, -61, -33이 써진 풍선으로 모두 6개입니다.

출처 : https://programmers.co.kr/learn/courses/30/lessons/68646



---



#### My solution (Java)

```java
class Solution {
  public int solution(int[] a) {
        int answer = 0;
        int index = 0;
        int min = Integer.MAX_VALUE;
      	/* 가장 작은 수를 찾는다 */
        for (int i = 0; i < a.length; i++) {
            if (a[i] < min) {
                index = i;
                min = a[i];
            }
        }
      	/* 가장 작은 수의 왼쪽, 오른쪽 element를 탐색 */
        int min1 = Integer.MAX_VALUE;
        int min2 = Integer.MAX_VALUE;
        for (int i = 0; i < a.length; i++) {
            if (i <= index && min1 > a[i]) {
                answer++;
                min1 = a[i];
            } else if (i > index && min2 > a[a.length - i + index]) {
                answer++;
                min2 = a[a.length - i + index];
            }
        }
        return answer;
    }
}
```



---

#### My logic & Feedback

숫자의 대소비교를 활용하여 O(N)으로 풀 수 있는 문제다. Level 3 치고는 쉽다.

우선 for문을 한 번 돌면서 가장 작은 수와 index를 찾는다.

그리고 그 index의 양쪽을 탐색하면 되는데, 

왼쪽은 **'오른쪽으로 가면서 자신보다 작은 element가 있는지'**

오른쪽은 **'왼쪽으로 가면서 자신보다 작은 element가 있는지'**

를 검사하면 된다.

예를 들어

```
[-16,27,65,-2,58,-92,-71,-68,-61,-33]
```

위 예제가 있을 때, 가장 작은 수는 -92, 인덱스는 5이다.

만약 문제의 조건이 ''자신보다 숫자가 큰 풍선만 터뜨릴 수 있다''라면, 답은 -92로 하나가 될 것이다.

그러나 조건이 **자신보다 숫자가 작은 풍선을 딱 한 번 터뜨릴 수 있다**이므로, -92도 어느순간 터뜨릴 수 있다는 소리다.

따라서 -92가 가장 첫 턴에 터졌다면 그 다음 남을 풍선은 **남아있는 풍선 중 최소값 풍선**, 즉 -71이 될 것이고,

-92가 두 번 째 턴에 터졌다면(첫 턴에 -71을 터뜨렸다고 하자) -68이 남을 풍선이 될 것이다.

다시 말해 -92의 오른편에 있는 풍선들은 자신의 오른쪽 편에 있는 풍선들이 자기보다 값이 모두 크다면 끝까지 남을 수 있고, -92의 왼편에 있는 풍선들은 자신의 왼쪽 편에 있는 풍선들이 자기보다 값이 모두 크다면 끝까지 남을 수 있다.

따라서 우선 최소값과 최소값 인덱스를 찾은 후, 왼쪽 오른쪽을 for문으로 동시에 탐색하면서 min값이 갱신되는 횟수를 반환하면 된다.

