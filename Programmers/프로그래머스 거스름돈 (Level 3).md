## 프로그래머스 거스름돈 (Level 3)

###### 문제 설명

Finn은 편의점에서 야간 아르바이트를 하고 있습니다. 야간에 손님이 너무 없어 심심한 Finn은 손님들께 거스름돈을 n 원을 줄 때 방법의 경우의 수를 구하기로 하였습니다.

예를 들어서 손님께 5원을 거슬러 줘야 하고 1원, 2원, 5원이 있다면 다음과 같이 4가지 방법으로 5원을 거슬러 줄 수 있습니다.

- 1원을 5개 사용해서 거슬러 준다.
- 1원을 3개 사용하고, 2원을 1개 사용해서 거슬러 준다.
- 1원을 1개 사용하고, 2원을 2개 사용해서 거슬러 준다.
- 5원을 1개 사용해서 거슬러 준다.

거슬러 줘야 하는 금액 n과 Finn이 현재 보유하고 있는 돈의 종류 money가 매개변수로 주어질 때, Finn이 n 원을 거슬러 줄 방법의 수를 return 하도록 solution 함수를 완성해 주세요.

##### 제한 사항

- n은 100,000 이하의 자연수입니다.
- 화폐 단위는 100종류 이하입니다.
- 모든 화폐는 무한하게 있다고 가정합니다.
- 정답이 커질 수 있으니, 1,000,000,007로 나눈 나머지를 return 해주세요.

------

##### 입출력 예

| n    | money   | result |
| ---- | ------- | ------ |
| 5    | [1,2,5] | 4      |

##### 입출력 예 설명

입출력 예 #1
문제의 예시와 같습니다.



- 출처 : https://programmers.co.kr/learn/courses/30/lessons/12907

---

#### My solution (Java)

  ```
class Solution {
   public int solution(int n, int[] money) {
        int[][] dp = new int[money.length][n + 1];
        for (int i = 0; i < money.length; i++) {
             for (int j = 0; j <= n; j++) {
                dp[i][j] = i != 0 ? (dp[i][j] + dp[i - 1][j]) % 1000000007 : dp[i][j];
                if (j - money[i] == 0) {
                    dp[i][j] = (dp[i][j] + 1) % 1000000007;
                } else if (j - money[i] > 0) {
                    dp[i][j] = (dp[i][j] + dp[i][j - money[i]]) % 1000000007;
                }
            }
        }
        return dp[money.length - 1][n];
    }
}
  ```



---

#### My logic & Feedback

하..이 문제는 결국 방법이 생각나지 않아 답지의 힌트를 봤다.

힌트를 안봤으면 절대 못풀었을거같다.

내가 몰랐던 DP 문제풀이법이었기 때문이다.

포인트는 2차원 배열의 생성으로, 각 동전으로 만들 수 있는 n원을 각 row에 숫자로 기입해나간다.

두 번째 행 부터는 자신의 위쪽 행을 참조하여 경우의 수를 전부 합하면서 더해나간다.

그러니까 하나의 **테이블을 생성하고 경우의 수 계산에 이용**한다는 것이 포인트로, 

이 풀이방법은 익혀놓으면 상당히 도움이 많이 될 것 같다.