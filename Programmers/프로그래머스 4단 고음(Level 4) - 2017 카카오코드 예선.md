## 프로그래머스 4단 고음(Level 4) - 2017 카카오코드 예선

**문제 설명**

U는 본인의 장기인 3단 고음으로 유명하다. 그러던 그녀가 어느 날 4단 고음을 성공했고 그녀의 고음은 학계에서 연구가 될 만큼 유명해졌다 [1].

[1] 견두헌, 배명진. “아이유의 고음 발성 특성 분석”, 한국음향학회, 2011년 춘계학술대회 학술발표논문지

폭포 밑 득음 수련을 하던 어느 날, 그녀는 4단 고음이 끝이 아님을 깨달았다. 3단 고음 직후 3단 고음을 연이어하거나, 3단 고음 중 다시 3단 고음을 해서 음높이를 올리는 방법이다. 어떤 순서로 3단 고음을 했는지에 따라 최종 음높이가 달라지기 때문에, 연속 3단 고음을 연습할 때마다 그 결과를 기록으로 남기기로 했다.

3단 고음은 다음과 같이 적용된다. 1단계에서는 음높이가 세 배가 되며, 2단계와 3단계에서 음높이가 각각 1씩 증가한다. 이를 기록으로 남길 때 * 와 + 기호를 사용하기로 했다. 즉, 3단 고음을 한 번 한 경우는 문자열로 나타내면 다음과 같다.

*++

이때 3단 고음을 마치고 연달아 3단 고음을 한 경우는 * + + * + + 와 같이 표현할 수 있다. 3단 고음의 2단계를 마친 후 3단 고음을 새로 시작한 다음, 나머지 단계를 이어서 하는 경우는 * + ''* + + ''+로 표현할 수 있다. (강조된 부분이 2번째 3단 고음을 부른 부분이다.)

이와 같이 * 와 + 로 구성된 문자열이 3단 고음의 규칙을 적용하여 만들 수 있는 문자열인 경우 '올바른 문자열'이라고 하자. 다음의 문자열은 3단 고음의 규칙으로 만들 수 있는 문자열이 아니므로 올바른 문자열이 아니다.

- +**+++
- *+++*+

올바른 문자열에 대해 음높이는 다음과 같이 계산할 수 있다. 시작 음높이는 항상 1이며, 문자열의 처음부터 순서대로 * 기호의 경우 3을 곱하고 + 기호의 경우 1을 더한다. *+*+++ 의 음높이를 계산하는 과정을 예로 들면 아래와 같다.

시작 음 높이: 1

| *    | +    | *    | +    | +    | +    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| *3   | +1   | *3   | +1   | +1   | +1   |

최종 음높이: 15

그날 기분에 따라 최종 음높이를 정하는 IU는 최종 음높이를 결정했을 때 서로 다른 3단 고음 문자열이 몇 가지나 있는지 궁금하다. 여러분의 도움이 필요하다.

### 입력 형식

- 입력은 `5` 이상 `2^31-1` 이하의 정수 `n`으로 주어진다.

### 출력 형식

- 입력을 만족하는 서로 다른 문자열의 수를 리턴한다.

### 예제 입출력

| n          | answer |
| ---------- | ------ |
| 15         | 1      |
| 24         | 0      |
| 41         | 2      |
| 2147483647 | 1735   |

### 예제에 대한 설명

세 번째 예제의 두 가지 경우는 다음과 같다.

```
**++++*++`
`*+**+++++
```

출처 : https://programmers.co.kr/learn/courses/30/lessons/1831



---



#### My solution (Java)

```java
class Solution {
    int answer = 0;

    public int solution(int n) {
        int multiplyThree = 0;
        int plusOne = 0;
        int theLargest = 1; // 가능한 n의 범위 중 가장 큰 값
        int theSmallest = 0; // 가능한 n의 범위 중 가장 작은 값

        /* n에 해당되는 multiplyThree(*) 와 plusOne(+) 의 개수 구하기 */
        while (theLargest < n && theLargest >= 0) {
            multiplyThree++;
            plusOne += 2;
            theLargest = theLargest * 3 + 2;
            theSmallest = (int) Math.pow(3, (double) multiplyThree) + plusOne;
        }
        /* n이 theSmallest ~ theLargest 의 범위 안에 없으면 0 return */
        if (n < theSmallest) {
            return answer;
        }
        verifyRecursion(n - 2, multiplyThree, plusOne - 2, 2);
        return answer;
    }

    public void verifyRecursion(int n, int multiplyThree, int plusOne, int numOfSparePlusOne) {
        /* n이 계속 줄어들다가 1이 되는 시점에서 재귀 탈출 */
        if (n == 1) {
            if (plusOne == 0 && multiplyThree == 0) {
                /* n이 1이면서 동시에 남아있는 +,* 기호가 없는 경우 정답 카운트 */
                answer++;
            }
            return;
        }
        /* n을 3으로 나눌 수 있으며, *을 붙였을 때 +도 2개가 붙어야 하므로 numOfSparePlusOne가 2 이상일 경우만 분기 */
        if (n % 3 == 0 && multiplyThree > 0 && numOfSparePlusOne >= 2) {
            verifyRecursion(n / 3, multiplyThree - 1, plusOne, numOfSparePlusOne - 2);
        }
        /* (+) 기호가 0 이상일 경우 분기 */
        if (plusOne > 0) {
            verifyRecursion(n - 1, multiplyThree, plusOne - 1, numOfSparePlusOne + 1);
        }
    }
}
```



---

#### My logic & Feedback

이 문제는 Level 4 정도 난이도는 아닌 것 같다. Level 3으로 나왔어도 그러려니 수긍했을 것 같은 문제다.

본 문제의 핵심은 입력 범위가 int의 끝인(...) 2147483647 까지이기 때문에, 

 완전탐색보다는 다른 접근법을 활용해야 한다는 점이다.

입력 범위가 작았다면 그냥 * 과 + 로 만들 수 있는 모든 경우를 구한 뒤 해당 경우가 주어진 n이면 카운트 하는 방식으로 하면 될테지만...21억이라는 괴랄한 숫자 앞에서 완전탐색을 했다간 stackoverflow 메시지를 보게 될 수 밖에 없다.

따라서 나는 애초에 문제 접근을 '주어진 n에서 가능한 경우를 거꾸로 유추해가는 방식'으로 접근을 시도하였고, 

이는 예전에 풀었던 Level 3 'N으로 표현' 의 문제풀이와 흡사한 다이내믹 프로그래밍 방식이다.

*++ 라는 기호를 한 쌍으로 보았을 때, 이 기호가 몇 쌍 주어진 경우 만들 수 있는 숫자의 범위는 한정적이다.

가령 *++ 두 쌍으로 만들 수 있는 최소값은 ***++++++ = 33 이며, 최대값은 *++ *++ *++ = 53 이다.

이처럼 *++ 쌍이 증가할 수록 만들어낼 수 있는 최대/최소값 범위를 유추할 수 있으며, 

반대로 입력값 n이 몇 쌍의 *++ 기호를 필요로 하는지 알아낼 수 있다.

따라서 우리는 입력값 n이 몇 개의 * 기호를 필요로 하는지, 몇 개의 + 기호를 필요로 하는지 알 수 있다.

그렇다면 주어진 *, + 기호 개수만을 가지고 n을 거꾸로 만들어나가면 된다.

(예) 입력값이 2147483647 인 경우, *기호는 19개, +기호는 38개로 만들어내야만 한다)

그렇다면 n을 어떻게 거꾸로 만들어나갈까?

*의 의미는 곱하기 3을 한다는 의미이다. 따라서 만약 어떤 수가 있고 * 기호가 붙여져서 만들어진 것이라면 그 수는 3으로 나누어떨어진다는 의미다.

예를들어  숫자 14의 경우, 4 * 3 + 2 로 나타낼 수 있는데, 이는 즉 4*++ 로 나타낼 수 있다는 말과 같다.

따라서 우리는 어떤 수가 주어졌을 때 그 수가 3으로 나누어떨어진다면 *를 거꾸로 붙여나갈 수 있으며,

3으로 나누어 떨어지지 않거나  혹은 3으로 나누어떨어지더라도 + 기호를 붙여 입력값에 -1을 해나가면 된다.

위 두 경우로 분기가 나누어지기 때문에 재귀를 두 방향으로 타는데, 

재귀를 타다가 최종 입력값n이 1이 되었을 때, 활용 가능한 *, + 기호가 남아있지 않다면 답이 될 수 있다.

여기서 주의해야할 점이 있다.

*를 거꾸로 붙여나갈 때 하나의 조건이 필요한데, *기호 다음에는 항상 두 개의 + 기호가 필요하다.

우리는 거꾸로 *를 붙여나가고 있기 때문에, 만약 *를 붙일 때 이미 붙여나갔던 기호 중 +기호가 2개 이상 존재하지 않는다면 *기호를 붙일수가 없다 (코드에서 numOfSparePlusOne의 의미).

따라서 재귀를 탈 때 현재 존재하는 +가 2개 이상일 때만 분기를 타도록 조건을 추가하면 된다.



본 문제는 Level 4 문제임에도 불구, 쫄지 않고 풀어보려 노력했고, 결국 풀렸다.

Level 3 문제를 풀었을 때와 Level 4 문제를 풀었을 때의 성취감은 차원이 다르다.